---
layout: post
title:  "Image de fond RWD avec des <code>media queries</code>"
slug: "006"
categories:
 - "Responsive Web Design"
prerequis:
 html: "bases"
 css: "media queries, unité relatives, principes du responsive web design"
 js: ""
 fiches:
  - "004"
---

## Acte 1

Vous devez réaliser un <i lang="en">container</i> de 800px de haut contenant lui-même trois zones. En dessous de 640px (que vous convertirez en unités relatives, bien sûr), les trois zones occupent 100% de la largeur disponible. Au dessus de 640px, les trois zones se partagent la largeur disponible (chaque zone est donc une colonne de ⅓).

Nous allons partir du code HTML suivant :

```html
<div class="images">
  <div class="resp-img"></div>
  <div class="resp-img"></div>
  <div class="resp-img"></div>
</div>
```

Et du code CSS suivant :

```css
/* Pour éviter d'avoir un espace entre les zones */
.images {
  font-size: 0px;
}
```

{: .solution}
Utilisez une `media query` pour définir un tel découpage.

{: .proposition}
Il s'agit dans un premier temps de mettre une hauteur sur les `div` représentant les trois zones.
Ensuite, il faut ajouter une `media query` précisant qu'au delà de 640px (soit 40em sur une base de taille de police de 16px), alors les `div` sont alignées côte-à-côte et occupent ⅓ de l'espace disponible.

{: .proposition}
```
.resp-img {
  height:800px;
}
@media screen and (min-width: 20em) {
  .resp-img {
    display: inline-block;
    width: 33.33%;
  }
}
```

## Acte 2

Vous disposez d'une même image de fond (une texture répétable) en trois largeurs différentes :

* [320.jpg](assets/320.jpg) (530 Ko)
* [640.jpg](assets/640.jpg) (202 Ko)
* [1024.jpg](assets/1024.jpg) (53 Ko)

Pour faciliter l'exercice, nous avons ajouté les dimensions sur chaque image (ce qui n'arriverait pas en conditions réelles).

Vous devez mettre une image de fond de la meilleur qualité possible sur les zones portant la classe `resp-img`. Sachant que le design change autour de 640px et qu'il faudra gérer à la fois les densités de pixel x1 et x2.

{: .solution}
Astuce : il faut penser en terme de surface de rendu d'image… et en déduire des `media queries` supplémentaires.

{: .proposition}
Commençons par mettre en place une image de fond. Nous allons utiliser la plus petite image possible par défaut (approche <i lang="en">mobile first</i>).

{: .proposition}
```
.resp-img {
  background-image: url(http://traindrop.github.io/fiches/006/assets/320.jpeg);
  background-align: center top;
  background-size: 100%;
}
```

{: .proposition}
Ensuite, il s'agit de définir si cette image est toujours la bonne en partant des contraintes connues et en essayant toujours d'avoir une image légèrement meilleure que nécessaire (les navigateurs savent mieux réduire qu'aggrandir). D'un point de vue mathémtique, cela donne `largeur de l'image à afficher >= surface de rendu de l'image × densité de pixels`. Or nous savons que la surface de rendu de l'image est égale à la largeur relative de rendu de l'image par rapport à la largeur totale, donc cela équivaut à : `largeur de l'image à afficher >= surface relative de rendu de l'image × largeur de l'écran × densité de pixels`.

{: .proposition}
Il s'agit ensuite d'appliquer cette formule à différent cas. Prenons le cas où nous sommes en dessous de 640px, avec une densité de pixels de 1. Nous avons alors `largeur de l'image à afficher >= 100% × largeur de l'écran × 1` ce qui donne `largeur de l'image à afficher >=  largeur de l'écran`. On affichera donc l'image de 320px jusqu`à 19.99em de large et l'image de 640px dès 20em. L'image de 1024px ne sera pas utilisée dans ce cas car nous étudions le cas où la largeur de l'écran est inférieure à 640px.

{: .proposition}
Prenons désormais un cas plus complexe : le cas où la largeur de l'écran est supérieure à 640px et la densité de 2. Nous avons alors `largeur de l'image à afficher >= 1/3 × largeur de l'écran × 2`, donc `largeur de l'écran <= 3/2 × largeur de l'image à afficher`. L'image de 320px ne servira pas (car 480px < 640px), celle de 640px servira jusqu'à 960px (60em) exclu et celle de 1024 au delà.

{: .proposition}
Une fois que tous les cas ont été calculés, on obtient toutes les `media queries` nécessaires pour ce cas relativement simple.
